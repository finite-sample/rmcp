name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/rmcp-ci

jobs:
  # Fast Python-only validation (no R required)
  python-checks:
    name: Python Linting & Unit Tests
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install black isort flake8 click jsonschema pytest pytest-asyncio
        pip install -e .
    
    - name: Run linting
      run: |
        black --check rmcp tests streamlit scripts
        isort --check-only rmcp tests streamlit scripts
        flake8 rmcp tests streamlit scripts
    
    - name: Run Python-only unit tests
      run: |
        # Test CLI basic functionality
        rmcp --version
        rmcp list-capabilities > /dev/null
        
        # Run all unit tests (Python-only, schema validation, etc.)
        pytest tests/unit/ -v --tb=short

  # Build Docker images for R testing (both development and production)
  docker-build:
    name: Build R Testing Environment
    runs-on: ubuntu-latest
    needs: [python-checks]
    if: github.ref == 'refs/heads/main' || github.event_name == 'pull_request'
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    outputs:
      image: ${{ steps.image.outputs.image }}
      production-image: ${{ steps.prod-image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
      production-digest: ${{ steps.prod-build.outputs.digest }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata for development image
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Extract metadata for production image  
      id: prod-meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch,suffix=-production
          type=sha,prefix={{branch}}-production-
          type=raw,value=production-latest,enable={{is_default_branch}}

    - name: Build and push development Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile
        target: development
        platforms: ${{ github.event_name == 'pull_request' && 'linux/amd64' || 'linux/amd64,linux/arm64' }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push production Docker image
      id: prod-build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile
        target: production
        platforms: ${{ github.event_name == 'pull_request' && 'linux/amd64' || 'linux/amd64,linux/arm64' }}
        push: true
        tags: ${{ steps.prod-meta.outputs.tags }}
        labels: ${{ steps.prod-meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: Generate artifact attestation for development image
      uses: actions/attest-build-provenance@v1
      with:
        subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        subject-digest: ${{ steps.build.outputs.digest }}
        push-to-registry: true

    - name: Generate artifact attestation for production image
      uses: actions/attest-build-provenance@v1
      with:
        subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        subject-digest: ${{ steps.prod-build.outputs.digest }}
        push-to-registry: true
    
    - name: Output image references
      id: image
      run: echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest" >> $GITHUB_OUTPUT
      
    - name: Output production image reference
      id: prod-image  
      run: echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production-latest" >> $GITHUB_OUTPUT

    - name: Test production image functionality
      run: |
        echo "üê≥ Testing production image functionality..."
        docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production-latest \
          python -c "import rmcp; print('‚úÖ Production image RMCP import successful')"
        docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production-latest \
          python -c "import fastapi, uvicorn, httpx; print('‚úÖ Production image HTTP transport ready')"
        docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production-latest \
          R -e "cat('‚úÖ Production image R version:', R.version.string, '\n')"
        echo "‚úÖ Production image functionality verified"

    - name: Compare image sizes
      run: |
        echo "üìä Comparing image sizes..."
        docker images --filter "reference=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"
        echo "‚úÖ Image size comparison completed"

  # Comprehensive R testing with real execution (replaces all R-specific jobs)
  r-testing:
    name: R Integration & Workflow Tests
    runs-on: ubuntu-latest
    needs: [python-checks, docker-build]
    if: github.ref == 'refs/heads/main' || github.event_name == 'pull_request'
    container:
      image: ${{ needs.docker-build.outputs.image }}
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
      options: --user root
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Setup Python environment in container
      run: |
        export PATH="/opt/venv/bin:$PATH"
        pip install -e .
    
    - name: Verify R and Python integration
      run: |
        export PATH="/opt/venv/bin:$PATH"
        python --version
        R --version | head -1
        python -c "from rmcp.r_integration import diagnose_r_installation; import json; print(json.dumps(diagnose_r_installation(), indent=2))"
    
    - name: Run R code style checks
      run: |
        cd rmcp/r_assets
        R -e "
        library(styler)
        files_to_check <- list.files(c('R', 'scripts'), pattern='[.]R\$', recursive=TRUE, full.names=TRUE)
        if (length(files_to_check) > 0) {
          style_results <- styler::style_file(files_to_check, dry='on', include_roxygen_examples = FALSE)
          if (any(style_results\$changed)) {
            cat('‚ùå R code style issues found\\n')
            quit(status=1)
          } else {
            cat('‚úÖ R code style check passed\\n')
          }
        }
        "
    
    - name: Diagnose environment before testing
      run: |
        export PATH="/opt/venv/bin:$PATH"
        echo "=== Environment Diagnostics ==="
        echo "Working directory: $(pwd)"
        echo "Python version: $(python --version)"
        echo "Python path: $(which python)"
        echo "Pip packages: $(pip list | grep -E '(pytest|rmcp)')"
        echo "R availability: $(which R || echo 'R not found')"
        if which R; then
          echo "R version: $(R --version | head -1)"
        fi
        echo "PYTHONPATH: $PYTHONPATH"
        echo "PATH: $PATH"
        echo "=== Test Discovery Diagnostics ==="
        pytest --collect-only tests/smoke/ -q || echo "Test collection failed"
        echo "=== Python Import Test ==="
        python -c "import rmcp; print('‚úÖ rmcp imported successfully')" || echo "‚ùå rmcp import failed"
        python -c "import rmcp.core.server; print('‚úÖ rmcp.core.server imported')" || echo "‚ùå rmcp.core.server import failed"
        echo "=== File System Check ==="
        ls -la tests/
        ls -la tests/smoke/
    
    - name: Run smoke tests (basic functionality)
      run: |
        export PATH="/opt/venv/bin:$PATH"
        # Ensure R is in PATH for skip condition checks  
        which R && export R_AVAILABLE=1 || export R_AVAILABLE=0
        echo "R available: $R_AVAILABLE"
        pytest tests/smoke/ -v --tb=short --cov=rmcp --cov-report=xml
    
    - name: Run protocol tests (MCP protocol validation)
      run: |
        export PATH="/opt/venv/bin:$PATH"
        which R && echo "‚úÖ R available for protocol tests" || echo "‚ö†Ô∏è R not available"
        pytest tests/integration/protocol/ -v --tb=short --cov=rmcp --cov-append
    
    - name: Run integration tests - tools (R tool integration)
      run: |
        export PATH="/opt/venv/bin:$PATH"
        which R && echo "‚úÖ R available for tool integration tests" || echo "‚ùå R required but not available"
        pytest tests/integration/tools/ -v --tb=short --cov=rmcp --cov-append
    
    - name: Run integration tests - transport (HTTP transport)
      run: |
        export PATH="/opt/venv/bin:$PATH"
        pytest tests/integration/transport/ -v --tb=short --cov=rmcp --cov-append
    
    - name: Run integration tests - core (server & registries)
      run: |
        export PATH="/opt/venv/bin:$PATH"
        which R && echo "‚úÖ R available for core integration tests" || echo "‚ö†Ô∏è R not available"
        pytest tests/integration/core/ -v --tb=short --cov=rmcp --cov-append
    
    - name: Run scenario tests (end-to-end user scenarios)
      run: |
        export PATH="/opt/venv/bin:$PATH"
        which R && echo "‚úÖ R available for scenario tests" || echo "‚ùå R required but not available"
        pytest tests/scenarios/ -v --tb=short --cov=rmcp --cov-append
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.xml
        flags: comprehensive
        name: comprehensive-coverage
        fail_ci_if_error: false
        token: ${{ secrets.CODECOV_TOKEN }}
    
    - name: Test CLI and MCP protocol
      run: |
        export PATH="/opt/venv/bin:$PATH"
        # Verify CLI works with R integration
        rmcp --version
        rmcp list-capabilities
        
        # Test basic MCP protocol with R tools
        echo '{"jsonrpc":"2.0","id":1,"method":"tools/list","params":{}}' | rmcp start --quiet | head -20

  # Production image testing and new scenario tests
  production-testing:
    name: Production & Advanced Scenario Tests
    runs-on: ubuntu-latest
    needs: [python-checks, docker-build]
    if: github.ref == 'refs/heads/main' || github.event_name == 'pull_request'
    container:
      image: ${{ needs.docker-build.outputs.production-image }}
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
      options: --user root
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Setup Python environment in production container
      run: |
        export PATH="/opt/venv/bin:$PATH"
        pip install -e .
    
    - name: Verify production container functionality
      run: |
        export PATH="/opt/venv/bin:$PATH"
        echo "üîí Testing production container functionality..."
        
        # Note: Running as root in CI for GitHub Actions permissions
        # Production deployments should override with --user or run as non-root
        CURRENT_USER=$(whoami)
        echo "CI container user: $CURRENT_USER (root for GitHub Actions permissions)"
        
        # Verify essential functionality
        python -c "import rmcp; print('‚úÖ RMCP import successful')"
        python -c "import fastapi, uvicorn, httpx; print('‚úÖ HTTP transport ready')"
        R -e "cat('‚úÖ R version:', R.version.string, '\n')"
        
        # Test that production image can run as non-root when configured
        echo "üîç Testing non-root capability..."
        python -c "
        import os, pwd
        try:
            # Check if rmcp user exists in the container
            rmcp_user = pwd.getpwnam('rmcp')
            print(f'‚úÖ Non-root user available: rmcp (uid={rmcp_user.pw_uid})')
        except KeyError:
            print('‚ö†Ô∏è rmcp user not found - this may be expected in CI')
        "
    
  # Docker scenario tests run outside production container (need Docker access)
  docker-scenarios:
    name: Docker Scenario Tests
    runs-on: ubuntu-latest
    needs: [python-checks, docker-build]
    if: github.ref == 'refs/heads/main' || github.event_name == 'pull_request'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"
    
    - name: Install dependencies for scenario tests
      run: |
        python -m pip install --upgrade pip
        pip install poetry
        poetry install --with dev
        
        echo "üê≥ Verifying Docker availability..."
        docker --version
        docker info
    
    - name: Run Docker deployment scenario tests
      env:
        RMCP_PRODUCTION_IMAGE: ${{ needs.docker-build.outputs.production-image }}
      run: |
        echo "üéØ Testing Docker deployment scenarios..."
        echo "Using production image: $RMCP_PRODUCTION_IMAGE"
        
        # Test basic Docker functionality
        poetry run pytest tests/scenarios/test_deployment_scenarios.py::TestDockerWorkflowValidation::test_docker_basic_functionality -v --tb=short
        
        # Test production image functionality (uses pre-built image)
        poetry run pytest tests/scenarios/test_deployment_scenarios.py::TestDockerProductionScenarios::test_docker_production_image_functionality -v --tb=short
        
        # Test security configuration
        poetry run pytest tests/scenarios/test_deployment_scenarios.py::TestDockerProductionScenarios::test_docker_security_configuration -v --tb=short
        
        # Test environment variables and volume mounts
        poetry run pytest tests/scenarios/test_deployment_scenarios.py::TestDockerProductionScenarios::test_docker_environment_variables -v --tb=short
        poetry run pytest tests/scenarios/test_deployment_scenarios.py::TestDockerProductionScenarios::test_docker_volume_mounts -v --tb=short
        
        # Test R environment
        poetry run pytest tests/scenarios/test_deployment_scenarios.py::TestDockerWorkflowValidation::test_docker_r_environment_validation -v --tb=short
        
        # Test end-to-end workflows  
        poetry run pytest tests/scenarios/test_deployment_scenarios.py::TestDockerWorkflowValidation::test_docker_mcp_protocol_communication -v --tb=short
        poetry run pytest tests/scenarios/test_deployment_scenarios.py::TestDockerWorkflowValidation::test_docker_complete_analysis_workflow -v --tb=short
        
        # Test performance and resource usage
        poetry run pytest tests/scenarios/test_deployment_scenarios.py::TestDockerWorkflowValidation::test_docker_performance_benchmarks -v --tb=short
        poetry run pytest tests/scenarios/test_deployment_scenarios.py::TestDockerWorkflowValidation::test_docker_resource_usage -v --tb=short
        
        # Test platform-specific features (cross-platform compatibility)
        poetry run pytest tests/scenarios/test_deployment_scenarios.py::TestDockerCrossplatformCompatibility::test_docker_platform_specific_features -v --tb=short
        
        echo "‚úÖ All Docker scenario tests completed"
    
    # Non-Docker scenario tests run in production container  
    - name: Run non-Docker scenario tests in production container
      container:
        image: ${{ needs.docker-build.outputs.production-image }}
        credentials:
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
        options: --user root
      run: |
        export PATH="/opt/venv/bin:$PATH"
        pip install -e .
        
        echo "üéØ Testing non-Docker scenario features in production container..."
        
        # Test concurrent request handling (doesn't need Docker)
        pytest tests/scenarios/test_claude_desktop_scenarios.py::TestClaudeDesktopPerformance::test_concurrent_requests -v --tb=short
        
        echo "‚úÖ Non-Docker scenario tests completed"
    
    # Test coverage validation runs on runner (outside container)
    - name: Validate complete test coverage
      run: |
        python -m pip install --upgrade pip
        pip install poetry
        poetry install --with dev
        
        echo "üìä Validating complete test coverage..."
        
        # Verify all 201 tests are collected (using poetry environment)
        TEST_COUNT=$(poetry run pytest --collect-only -q tests/ | grep "collected" | grep -o '[0-9]\+' | head -1)
        echo "Tests collected: $TEST_COUNT"
        
        if [ "$TEST_COUNT" != "201" ]; then
          echo "‚ùå Expected 201 tests, but collected $TEST_COUNT"
          exit 1
        else
          echo "‚úÖ All 201 tests successfully collected"
        fi
        
        # Run a sample to verify no collection issues
        poetry run pytest tests/smoke/ -v --tb=short
        echo "‚úÖ Test collection and execution verified"

  # Cross-platform Python testing (validates Python-only functionality)
  cross-platform:
    name: Cross-platform Python Tests
    runs-on: ${{ matrix.os }}
    needs: [python-checks]
    
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        python-version: ["3.11"]
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install poetry
        poetry install --with dev
    
    - name: Test Python imports and basic functionality (no R)
      run: |
        poetry run python -c "from rmcp.core.server import create_server; print('‚úÖ Server creation works')"
        poetry run rmcp --version
        poetry run rmcp list-capabilities
        
        # Run Python-only unit tests
        poetry run pytest tests/unit/ -v --tb=short
